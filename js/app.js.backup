// app.js
import { roll3D, rollFallback, coinFlip } from './anim.js';
import { playRollSound, playConfirmSound, playJokerSound } from './sfx.js';
import { initDB, getData, updateItem, deleteItem, addItem, addRecipeToCookbook, getCookbook, replaceInventoryData } from './storage.js';
import { violatesHardBan, getSoftWeight } from './rules.js';
import { cryptoRoll, cryptoChoice, weightedCryptoChoice } from './rng.js';
import { generateRecipeDetails } from './measure.js';
import { generateSVG, downloadSVG, encodeShareCode, decodeShareCode } from './exporter.js';

console.log('App loaded.');

const appContainer = document.getElementById('app-container');

let data = {};

const state = {
    currentState: 'LOADING',
    sessionActive: false,
    recipe: {
        spirits: [],
        spiritFamilies: [],
        mixers: [],
        additives: [],
        secondaries: []
    },
    rerollTokens: 1,
    selectedItems: []
};

// Progress drawer state
let progressDrawer = {
    isOpen: true,
    steps: [],
    currentStep: 0
};

// Progress drawer DOM element
let progressDrawerElement = null;

const states = {
    LOADING: {
        enter: async () => {
            console.log('Entering LOADING state');
            appContainer.innerHTML = '<h2>Loading...</h2>';
            try {
                await initDB();
                data = await getData();
                console.log('Data loaded', data);
                // Initialize progress drawer
                initProgressDrawer();
                // If URL includes a share code, decode it and offer to save to Recipe Book
                const hash = (window.location && window.location.hash) ? window.location.hash.slice(1) : '';
                if (hash) {
                    try {
                        const decoded = decodeShareCode(hash);
                        if (decoded) {
                            // Show modal to confirm save or view only
                            showShareCodeImportModal(decoded);
                        } else {
                            transitionTo('IDLE');
                        }
                    } catch (e) {
                        console.warn('Invalid share code in URL:', e);
                        transitionTo('IDLE');
                    }
                } else {
                    transitionTo('IDLE');
                }
            } catch (error) {
                console.error('Failed to initialize and load data:', error);
                appContainer.innerHTML = '<h2>Error loading data. Please refresh.</h2>';
            }
        }
    },
    IDLE: {
        enter: () => {
            console.log('Entering IDLE state');
            state.sessionActive = false;
            state.rerollTokens = 1;
            state.selectedItems = [];
            state.recipe = { 
                spirits: [], 
                spiritFamilies: [], 
                mixers: [], 
                additives: [],
                secondaries: []
            };
            appContainer.innerHTML = `
                <div class="home-container">
                    <button id="roll-cta">Roll</button>
                </div>
                <div class="bottom-nav">
                    <button id="inventory-nav">Inventory</button>
                    <button id="recipe-book-nav">Recipe Book</button>
                    <button id="settings-nav">Settings</button>
                </div>
            `;
            document.getElementById('roll-cta').addEventListener('click', () => transitionTo('METHOD', { type: 'drink' }));
            document.getElementById('inventory-nav').addEventListener('click', () => transitionTo('INVENTORY'));
            document.getElementById('recipe-book-nav').addEventListener('click', () => transitionTo('RECIPE_BOOK'));
            document.getElementById('settings-nav').addEventListener('click', () => {
                // Placeholder for settings
                renderDevPanel();
            });

            // Reset and hide progress drawer when returning to IDLE
            initProgressDrawer();
            const progressContainer = document.getElementById('progress-drawer-container');
            if (progressContainer) {
                progressContainer.style.display = 'none';
            }
        },
        exit: () => {
            console.log('Exiting IDLE state');
        }
    },
    METHOD: {
        enter: (context) => {
            console.log(`Entering METHOD state for: ${context.type}`);
            state.sessionActive = true;
            state.recipe.type = context.type;
            
            // Add to progress
            initProgressDrawer();
            addProgressStep(`New ${context.type}`);

            let methods;
            if (context.type === 'drink') {
                methods = ['Shaken', 'Stirred', 'Blended', 'ðŸƒ'];
            } else {
                methods = ['Shaken', 'Stirred', 'Layered', 'ðŸƒ'];
            }

            appContainer.innerHTML = `
                <h2>Choose a Method</h2>
                <div class="options-container">
                    ${methods.map(m => `<div class="option" data-method="${m}">${m}</div>`).join('')}
                </div>
                <div class="roll-actions">
                    <button id="roll-method-btn">Roll</button>
                    <button id="next-method-btn" style="display:none;">Next</button>
                </div>
            `;

            const rollBtn = document.getElementById('roll-method-btn');
            const nextBtn = document.getElementById('next-method-btn');

            rollBtn.addEventListener('click', async () => {
                const methodsCore = (state.recipe.type === 'drink')
                    ? ['Shaken', 'Stirred', 'Blended']
                    : ['Shaken', 'Stirred', 'Layered'];

                const joker = cryptoRoll(20) === 20; // 1-in-20 Dealer's Choice
                let picked;
                if (joker) {
                    picked = 'ðŸƒ';
                } else {
                    picked = cryptoChoice(methodsCore);
                }

                const optionsContainer = document.querySelector('.options-container');
                
                if (methodsCore.length <= 2) {
                    optionsContainer.innerHTML = ''; // Clear options
                    coinFlip({ parent: optionsContainer, onComplete: () => {
                        document.querySelectorAll('.option').forEach(opt => opt.classList.remove('highlighted'));
                        const selectedOption = document.querySelector(`[data-method="${picked}"]`);
                        if (selectedOption) {
                            selectedOption.classList.add('highlighted');
                        }
                        state.recipe.method = picked;
                        rollBtn.style.display = 'none';
                        nextBtn.style.display = 'inline-block';
                    }});
                } else {
                    document.querySelectorAll('.option').forEach(opt => opt.classList.remove('highlighted'));
                    const selectedOption = document.querySelector(`[data-method="${picked}"]`);
                    if (selectedOption) {
                        selectedOption.classList.add('highlighted');
                    }
    
                    state.recipe.method = picked;
                    rollBtn.style.display = 'none';
                    nextBtn.style.display = 'inline-block';
                }
            });

            nextBtn.addEventListener('click', () => {
                const selectedOption = document.querySelector('.option.highlighted');
                if (selectedOption) {
                    highlightAndSlideUp(selectedOption, () => {
                        addProgressStep(`Method: ${state.recipe.method}`);
                        if (state.recipe.type === 'drink') {
                            transitionTo('ROCKS_NEAT');
                        } else {
                            transitionTo('HOW_MANY');
                        }
                    });
                }
            });
        },
        exit: () => {
            console.log('Exiting METHOD state');
        }
    },
    ROCKS_NEAT: {
        enter: () => {
            console.log('Entering ROCKS_NEAT state');
            const options = ['Rocks', 'Neat'];

            appContainer.innerHTML = `
                <h2>Style</h2>
                <div class="options-container">
                    ${options.map(o => `<div class="option" data-style="${o}">${o}</div>`).join('')}
                    <div class="coin-overlay" style="display:none;"></div>
                </div>
                <div class="roll-actions">
                    <button id="roll-style-btn">Roll</button>
                    <button id="next-style-btn" style="display:none;">Next</button>
                </div>
            `;

            const rollBtn = document.getElementById('roll-style-btn');
            const nextBtn = document.getElementById('next-style-btn');

            rollBtn.addEventListener('click', () => {
                const picked = cryptoChoice(options);
                const optionsContainer = document.querySelector('.options-container');
                const overlay = optionsContainer.querySelector('.coin-overlay');
                if (overlay) {
                    overlay.style.display = 'block';
                    coinFlip({ parent: overlay, onComplete: () => {
                        overlay.style.display = 'none';
                        document.querySelectorAll('.option').forEach(opt => opt.classList.remove('highlighted'));
                        const selectedOption = document.querySelector(`[data-style="${picked}"]`);
                        if (selectedOption) {
                            selectedOption.classList.add('highlighted');
                        }
                        state.recipe.style = picked;
                        rollBtn.style.display = 'none';
                        nextBtn.style.display = 'inline-block';
                    }});
                } else {
                    // Fallback: no overlay container
                    document.querySelectorAll('.option').forEach(opt => opt.classList.remove('highlighted'));
                    const selectedOption = document.querySelector(`[data-style="${picked}"]`);
                    if (selectedOption) selectedOption.classList.add('highlighted');
                    state.recipe.style = picked;
                    rollBtn.style.display = 'none';
                    nextBtn.style.display = 'inline-block';
                }
            });

            nextBtn.addEventListener('click', () => {
                const selectedOption = document.querySelector('.option.highlighted');
                if (selectedOption) {
                    highlightAndSlideUp(selectedOption, () => {
                        addProgressStep(`Style: ${state.recipe.style}`);
                        transitionTo('HOW_MANY');
                    });
                }
            });
        },
        exit: () => {
            console.log('Exiting ROCKS_NEAT state');
        }
    },
    HOW_MANY: {
        enter: () => {
            console.log('Entering HOW_MANY state');
            appContainer.innerHTML = `
                <h2>How Many?</h2>
                <div class="options-container">
                    <div class="option" data-type="spirits">Spirits</div>
                    <div class="option" data-type="mixers">Mixers</div>
                    <div class="option" data-type="additives">Additives</div>
                </div>
                <div class="roll-actions">
                    <button id="roll-how-many-btn">Roll</button>
                    <button id="next-how-many-btn" style="display:none;">Next</button>
                </div>
            `;

            const rollBtn = document.getElementById('roll-how-many-btn');
            const nextBtn = document.getElementById('next-how-many-btn');

            rollBtn.addEventListener('click', () => {
                const numSpirits = cryptoRoll(3);
                const numMixers = cryptoRoll(4);
                const numAdditives = cryptoRoll(2);

                document.querySelector('[data-type="spirits"]').textContent = `${numSpirits} Spirits`;
                document.querySelector('[data-type="mixers"]').textContent = `${numMixers} Mixers`;
                document.querySelector('[data-type="additives"]').textContent = `${numAdditives} Additives`;

                state.recipe.numSpirits = numSpirits;
                state.recipe.numMixers = numMixers;
                state.recipe.numAdditives = numAdditives;

                rollBtn.style.display = 'none';
                nextBtn.style.display = 'inline-block';
            });

            nextBtn.addEventListener('click', () => {
                addProgressStep(`How Many: ${state.recipe.numSpirits} Spirits, ${state.recipe.numMixers} Mixers, ${state.recipe.numAdditives} Additives`);
                transitionTo('PICKS');
            });
        },
        exit: () => {
            console.log('Exiting HOW_MANY state');
        }
    },
    PICKS: {
        enter: () => {
            console.log('Entering PICKS state');
            // Initialize arrays if they don't exist
            if (!state.recipe.spiritFamilies) {
                state.recipe.spiritFamilies = [];
            }
            if (!state.recipe.secondaries) {
                state.recipe.secondaries = [];
            }
            
            // Check if we need to pick spirit families first
            if (state.recipe.spiritFamilies.length < state.recipe.numSpirits) {
                transitionTo('PICK_SPIRIT_FAMILY');
            } else if (state.recipe.spirits.length < state.recipe.numSpirits) {
                transitionTo('PICK_SPIRIT');
            } else if (state.recipe.mixers.length < state.recipe.numMixers) {
                transitionTo('PICK_MIXER');
            } else if (state.recipe.additives.length < state.recipe.numAdditives) {
                transitionTo('PICK_ADDITIVE');
            } else {
                // Check if we need to pick secondary items for mixers
                const mixersRequiringSecondary = state.recipe.mixers.filter(m => m.requires_secondary);
                const mixerSecondaries = state.recipe.secondaries.filter(s => s.parentType === 'mixer');
                if (mixersRequiringSecondary.length > mixerSecondaries.length) {
                    transitionTo('PICK_SECONDARY');
                    return;
                } 
                // Check if we need to pick secondary items for additives
                const additivesRequiringSecondary = state.recipe.additives.filter(a => a.requires_secondary);
                const additiveSecondaries = state.recipe.secondaries.filter(s => s.parentType === 'additive');
                if (additivesRequiringSecondary.length > additiveSecondaries.length) {
                    transitionTo('PICK_SECONDARY');
                    return;
                }
                transitionTo('RECIPE');
            }
        }
    },
    PICK_SPIRIT_FAMILY: {
        enter: async () => {
            console.log('Entering PICK_SPIRIT_FAMILY state');
            const spiritFamilies = data.inventory.spirits.filter(spirit => spirit.type === 'family' && spirit.in_rotation);

            if (spiritFamilies.length === 0) {
                console.error('No spirit families available');
                return;
            }

            let rolledFamilies = [];

            appContainer.innerHTML = `
                <h2>Spirit Families</h2>
                <div class="options-container">
                    ${spiritFamilies.map(f => `<div class="option" data-name="${f.name}">${f.name}</div>`).join('')}
                </div>
                <div class="roll-actions">
                    <button id="roll-spirit-family-btn">Roll</button>
                    <button id="next-spirit-family-btn" style="display:none;">Next</button>
                </div>
            `;

            const rollBtn = document.getElementById('roll-spirit-family-btn');
            const nextBtn = document.getElementById('next-spirit-family-btn');

            rollBtn.addEventListener('click', async () => {
                rolledFamilies = await rollForUniqueItems('spirit_family', state.recipe.numSpirits, spiritFamilies);
                document.querySelectorAll('.option').forEach(opt => opt.classList.remove('highlighted'));
                rolledFamilies.forEach(f => {
                    const el = document.querySelector(`.option[data-name="${f.name}"]`);
                    if (el) el.classList.add('highlighted');
                });
                rollBtn.style.display = 'none';
                nextBtn.style.display = 'inline-block';
            });

            nextBtn.addEventListener('click', () => {
                const selectedOptions = document.querySelectorAll('.option.highlighted');
                selectedOptions.forEach(option => highlightAndSlideUp(option, () => {}));
                setTimeout(() => {
                    state.recipe.spiritFamilies.push(...rolledFamilies);
                    addProgressStep(`${rolledFamilies.length} Spirit Families`);
                    transitionTo('PICKS');
                }, 500);
            });
        }
    },
    PICK_SPIRIT: {
        enter: async () => {
            console.log('Entering PICK_SPIRIT state');
            let rolledSpirits = [];

            appContainer.innerHTML = `
                <h2>Spirits</h2>
                <div class="options-container" id="spirits-results">
                    <!-- Roll to reveal selected spirits -->
                </div>
                <div class="roll-actions">
                    <button id="roll-spirits-btn">Roll</button>
                    <button id="next-spirits-btn" style="display:none;">Next</button>
                </div>
            `;

            const rollBtn = document.getElementById('roll-spirits-btn');
            const nextBtn = document.getElementById('next-spirits-btn');
            const results = document.getElementById('spirits-results');

            rollBtn.addEventListener('click', async () => {
                rolledSpirits = [];
                for (const family of state.recipe.spiritFamilies) {
                    let subpoolItems = [];
                    if (family.subpool_id && data.subpools[family.subpool_id]) {
                        subpoolItems = data.subpools[family.subpool_id].filter(item => item.in_rotation);
                    }

                    if (subpoolItems.length === 0) {
                        rolledSpirits.push(family);
                        continue;
                    }

                    const availableItems = subpoolItems.filter(item => !violatesHardBan(item, state.selectedItems.concat(rolledSpirits), data.rules.hard_bans));
                    if (availableItems.length === 0) {
                        showNoSolutionMessage('No compatible spirits available in this category.');
                        return;
                    }

                    const weights = availableItems.map(item => getSoftWeight(item, state.selectedItems.concat(rolledSpirits), data.rules.soft_rules));
                    const spirit = weightedCryptoChoice(availableItems, weights);
                    rolledSpirits.push(spirit);
                }

                results.innerHTML = rolledSpirits.map(s => `<div class="option highlighted">${s.name}</div>`).join('');
                rollBtn.style.display = 'none';
                nextBtn.style.display = 'inline-block';
            });

            nextBtn.addEventListener('click', () => {
                document.querySelectorAll('#spirits-results .option.highlighted').forEach(option => highlightAndSlideUp(option, () => {}));
                setTimeout(() => {
                    state.recipe.spirits.push(...rolledSpirits);
                    addProgressStep(`${rolledSpirits.length} Spirits`);
                    transitionTo('PICKS');
                }, 500);
            });
        }
    },
    PICK_MIXER: {
        enter: async () => {
            console.log('Entering PICK_MIXER state');
            const availableMixers = data.inventory.mixers.filter(mixer => 
                mixer.in_rotation && !violatesHardBan(mixer, state.selectedItems, data.rules.hard_bans));
            
            if (availableMixers.length === 0) {
                showNoSolutionMessage('No compatible mixers available in this category.');
                return;
            }

            let rolledMixers = [];

            appContainer.innerHTML = `
                <h2>Mixers</h2>
                <div class="options-container">
                    ${availableMixers.map(m => `<div class="option" data-name="${m.name}">${m.name}</div>`).join('')}
                </div>
                <div class="roll-actions">
                    <button id="roll-mixers-btn">Roll</button>
                    <button id="next-mixers-btn" style="display:none;">Next</button>
                </div>
            `;

            const rollBtn = document.getElementById('roll-mixers-btn');
            const nextBtn = document.getElementById('next-mixers-btn');

            rollBtn.addEventListener('click', async () => {
                rolledMixers = await rollForUniqueItems('mixer', state.recipe.numMixers, availableMixers);
                document.querySelectorAll('.option').forEach(opt => opt.classList.remove('highlighted'));
                rolledMixers.forEach(m => {
                    const el = document.querySelector(`.option[data-name="${m.name}"]`);
                    if (el) el.classList.add('highlighted');
                });
                rollBtn.style.display = 'none';
                nextBtn.style.display = 'inline-block';
            });

            nextBtn.addEventListener('click', () => {
                const selectedOptions = document.querySelectorAll('.option.highlighted');
                selectedOptions.forEach(option => highlightAndSlideUp(option, () => {}));
                setTimeout(() => {
                    state.recipe.mixers.push(...rolledMixers);
                    addProgressStep(`${rolledMixers.length} Mixers`);
                    transitionTo('PICKS');
                }, 500);
            });
        }
    },
    PICK_SECONDARY: {
        enter: () => {
            console.log('Entering PICK_SECONDARY state');
            
            // Determine what type of parent item needs a secondary
            let parentItem = null;
            let parentType = null;
            
            // Check mixers first
            const mixersRequiringSecondary = state.recipe.mixers.filter(m => m.requires_secondary);
            const mixerSecondaries = state.recipe.secondaries.filter(s => s.parentType === 'mixer');
            
            if (mixersRequiringSecondary.length > mixerSecondaries.length) {
                // Find the last mixer that requires a secondary but doesn't have one yet
                for (let i = mixersRequiringSecondary.length - 1; i >= 0; i--) {
                    const mixer = mixersRequiringSecondary[i];
                    const hasSecondary = state.recipe.secondaries.some(s => s.parentId === mixer.id);
                    if (!hasSecondary) {
                        parentItem = mixer;
                        parentType = 'mixer';
                        break;
                    }
                }
            } else {
                // Check additives
                const additivesRequiringSecondary = state.recipe.additives.filter(a => a.requires_secondary);
                const additiveSecondaries = state.recipe.secondaries.filter(s => s.parentType === 'additive');
                
                if (additivesRequiringSecondary.length > additiveSecondaries.length) {
                    // Find the last additive that requires a secondary but doesn't have one yet
                    for (let i = additivesRequiringSecondary.length - 1; i >= 0; i--) {
                        const additive = additivesRequiringSecondary[i];
                        const hasSecondary = state.recipe.secondaries.some(s => s.parentId === additive.id);
                        if (!hasSecondary) {
                            parentItem = additive;
                            parentType = 'additive';
                            break;
                        }
                    }
                }
            }
            
            if (!parentItem || !parentType) {
                // This shouldn't happen, but just in case
                transitionTo('PICKS');
                return;
            }
            
            // Get items from the secondary pool
            let secondaryItems = [];
            if (data.secondary[parentItem.requires_secondary]) {
                secondaryItems = data.secondary[parentItem.requires_secondary].filter(item => item.in_rotation);
            }

            if (secondaryItems.length === 0) {
                // No secondary items available, continue to next pick
                transitionTo('PICKS');
                return;
            }

            // Apply hard bans and soft weights
            let availableItems = secondaryItems.filter(item => !violatesHardBan(item, state.selectedItems, data.rules.hard_bans));
            
            if (availableItems.length === 0) {
                // Handle no solution - revert one step
                console.log('No available secondary items after applying hard bans');
                showNoSolutionMessage('No compatible secondary items available in this category.');
                return;
            }

            // Store parent info in each available item for later reference
            availableItems = availableItems.map(item => ({
                ...item,
                parentId: parentItem.id,
                parentType: parentType
            }));

            if (cryptoRoll(20) === 20) {
                displayAnimatedPick({ name: 'ðŸƒ' }, 'secondary', availableItems);
            } else {
                const weights = availableItems.map(item => getSoftWeight(item, state.selectedItems, data.rules.soft_rules));
                let secondary = weightedCryptoChoice(availableItems, weights);
                displayAnimatedPick(secondary, 'secondary', availableItems);
            }
        }
    },
    PICK_ADDITIVE: {
        enter: async () => {
            console.log('Entering PICK_ADDITIVE state');
            const availableAdditives = data.inventory.additives.filter(additive => 
                additive.in_rotation && !violatesHardBan(additive, state.selectedItems, data.rules.hard_bans));
            
            if (availableAdditives.length === 0) {
                showNoSolutionMessage('No compatible additives available in this category.');
                return;
            }

            let rolledAdditives = [];

            appContainer.innerHTML = `
                <h2>Additives</h2>
                <div class="options-container">
                    ${availableAdditives.map(a => `<div class="option" data-name="${a.name}">${a.name}</div>`).join('')}
                </div>
                <div class="roll-actions">
                    <button id="roll-additives-btn">Roll</button>
                    <button id="next-additives-btn" style="display:none;">Next</button>
                </div>
            `;

            const rollBtn = document.getElementById('roll-additives-btn');
            const nextBtn = document.getElementById('next-additives-btn');

            rollBtn.addEventListener('click', async () => {
                rolledAdditives = await rollForUniqueItems('additive', state.recipe.numAdditives, availableAdditives);
                document.querySelectorAll('.option').forEach(opt => opt.classList.remove('highlighted'));
                rolledAdditives.forEach(a => {
                    const el = document.querySelector(`.option[data-name="${a.name}"]`);
                    if (el) el.classList.add('highlighted');
                });
                rollBtn.style.display = 'none';
                nextBtn.style.display = 'inline-block';
            });

            nextBtn.addEventListener('click', () => {
                const selectedOptions = document.querySelectorAll('.option.highlighted');
                selectedOptions.forEach(option => highlightAndSlideUp(option, () => {}));
                setTimeout(() => {
                    state.recipe.additives.push(...rolledAdditives);
                    addProgressStep(`${rolledAdditives.length} Additives`);
                    transitionTo('PICKS');
                }, 500);
            });
        }
    },
    RECIPE: {
        enter: () => {
            console.log('Entering RECIPE state');
            const recipeDetails = generateRecipeDetails(state.recipe);

            let html = '<h2>Your Recipe:</h2>';
            html += `<h3>${state.recipe.name || 'My Dicey Drink'}</h3>`;
            html += `<p>Method: ${state.recipe.method}</p>`;

            html += '<h4>Ingredients:</h4><ul>';
            recipeDetails.ingredientsWithVolumes.forEach(item => {
                html += `<li>${item.volume} ${item.name}</li>`;
            });
            html += '</ul>';

            html += '<h4>Instructions:</h4><ol>';
            recipeDetails.instructions.forEach(step => {
                html += `<li>${step}</li>`;
            });
            html += '</ol>';

            html += '<button id="export-svg-btn">Export SVG</button>';
            if (navigator.share) {
                html += '<button id="share-btn">Share Recipe</button>';
            }
            html += '<button id="new-drink-btn">New Drink</button>';

            html += `
                <hr>
                <h3>Rate and Save</h3>
                <form id="save-recipe-form">
                    <label>Rating (1-5): <input type="number" id="recipe-rating" min="1" max="5" value="5"></label><br>
                    <label>Notes: <textarea id="recipe-notes"></textarea></label><br>
                    <button type="submit">Save to Recipe Book</button>
                </form>
            `;

            appContainer.innerHTML = html;

            document.getElementById('export-svg-btn').addEventListener('click', () => {
                const svg = generateSVG(state.recipe, recipeDetails);
                downloadSVG(svg);
            });

            if (navigator.share) {
                document.getElementById('share-btn').addEventListener('click', async () => {
                    try {

                        const recipeName = state.recipe.name || 'My Dicey Drink';
                        const textHeader = `Check out this recipe for ${recipeName}!`;

                        const text = `${textHeader}

Ingredients:
${recipeDetails.ingredientsWithVolumes.map(i => `- ${i.volume} ${i.name}`).join('\n')}

Instructions:
${recipeDetails.instructions.map((step, i) => `${i+1}. ${step}`).join('\n')}
`;

                        await navigator.share({ title: recipeName, text, url: window.location.href });
                    } catch (error) {
                        console.log('Sharing failed:', error);
                        const svg = generateSVG(state.recipe, recipeDetails);
                        downloadSVG(svg);
                    }
                });
            }

            const shareCodeBtn = document.createElement('button');
            shareCodeBtn.id = 'share-code-btn';
            shareCodeBtn.textContent = 'Get Share Code';
            shareCodeBtn.style.marginLeft = '10px';
            const exportBtn = document.getElementById('export-svg-btn');
            if (exportBtn && exportBtn.parentNode) {
                exportBtn.insertAdjacentElement('afterend', shareCodeBtn);
            } else {
                appContainer.appendChild(shareCodeBtn);
            }

            document.getElementById('share-code-btn').addEventListener('click', () => {
                const shareCode = encodeShareCode(state.recipe);
                if (!shareCode) {
                    alert('Unable to generate share code.');
                    return;
                }
                const baseUrl = window.location.origin + window.location.pathname;
                const shareUrl = `${baseUrl}#${shareCode}`;
                (navigator.clipboard && navigator.clipboard.writeText ?
                    navigator.clipboard.writeText(shareUrl) : Promise.reject()
                ).then(() => {
                    alert('Shareable URL copied to clipboard!');
                }).catch(() => {
                    const textArea = document.createElement('textarea');
                    textArea.value = shareUrl;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    alert('Shareable URL copied to clipboard!');
                });
            });

            document.getElementById('new-drink-btn').addEventListener('click', () => {
                transitionTo('IDLE');
            });

            document.getElementById('save-recipe-form').addEventListener('submit', (e) => {
                e.preventDefault();
                state.recipe.rating = parseInt(document.getElementById('recipe-rating').value);
                state.recipe.notes = document.getElementById('recipe-notes').value;
                state.recipe.date = new Date().toISOString();
                addRecipeToCookbook(state.recipe);
                addProgressStep('Recipe Saved');
                transitionTo('RECIPE_BOOK');
            });
            
            // Add progress step for recipe completion
            addProgressStep('Recipe Complete');
        },
        exit: () => {
            console.log('Exiting RECIPE state');
        }
    },
    INVENTORY: {
        enter: () => {
            console.log('Entering INVENTORY state');
            let html = '<h2>Inventory Management</h2>';
            html += '<button id="back-to-idle">Back</button>';
            
            // Add import/export buttons
            html += `<div style="margin: 10px 0;">
                <button id="export-inventory">Export Inventory</button>
                <button id="import-inventory">Import Inventory</button>
            </div>`;

            html += '<h3>Spirits</h3>';
            html += '<ul>';
            data.inventory.spirits.forEach(item => {
                html += `<li>${item.name} <button class="archive-btn" data-id="${item.id}">${item.in_rotation ? 'Archive' : 'Unarchive'}</button><button class="delete-btn" data-id="${item.id}">Delete</button></li>`;
            });
            html += '</ul>';

            html += '<h3>Mixers</h3>';
            html += '<ul>';
            data.inventory.mixers.forEach(item => {
                html += `<li>${item.name} <button class="archive-btn" data-id="${item.id}">${item.in_rotation ? 'Archive' : 'Unarchive'}</button><button class="delete-btn" data-id="${item.id}">Delete</button></li>`;
            });
            html += '</ul>';

            html += '<h3>Additives</h3>';
            html += '<ul>';
            data.inventory.additives.forEach(item => {
                html += `<li>${item.name} <button class="archive-btn" data-id="${item.id}">${item.in_rotation ? 'Archive' : 'Unarchive'}</button><button class="delete-btn" data-id="${item.id}">Delete</button></li>`;
            });
            html += '</ul>';

            html += `
                <h3>Add New Item</h3>
                <form id="add-item-form">
                    <label>Category: 
                        <select id="item-category">
                            <option value="spirits">Spirit</option>
                            <option value="mixers">Mixer</option>
                            <option value="additives">Additive</option>
                        </select>
                    </label><br>
                    <label>ID: <input type="text" id="item-id" required></label><br>
                    <label>Name: <input type="text" id="item-name" required></label><br>
                    <label>Traits: <input type="text" id="item-traits"></label><br>
                    <button type="submit">Add Item</button>
                </form>
            `;

            appContainer.innerHTML = html;

            document.getElementById('back-to-idle').addEventListener('click', () => transitionTo('IDLE'));
            
            // Add export inventory functionality
            document.getElementById('export-inventory').addEventListener('click', () => exportInventory());
            
            // Add import inventory functionality
            document.getElementById('import-inventory').addEventListener('click', () => importInventory());

            document.querySelectorAll('.archive-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const itemId = e.target.dataset.id;
                    const item = findItem(itemId);
                    if (item) {
                        item.in_rotation = !item.in_rotation;
                        await updateItem(item);
                        data = await getData(); // Refresh data
                        transitionTo('INVENTORY'); // Re-render
                    }
                });
            });

            document.querySelectorAll('.delete-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const itemId = e.target.dataset.id;
                    await deleteItem(itemId);
                    data = await getData(); // Refresh data
                    transitionTo('INVENTORY'); // Re-render
                });
            });

            document.getElementById('add-item-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const category = document.getElementById('item-category').value;
                const id = document.getElementById('item-id').value;
                const name = document.getElementById('item-name').value;
                const traits = document.getElementById('item-traits').value.split(',').map(t => t.trim());
                const newItem = { id: `${category}.${id}`, name, traits, in_rotation: true };
                await addItem(newItem);
                data = await getData();
                transitionTo('INVENTORY');
            });
        },
        exit: () => {
            console.log('Exiting INVENTORY state');
        }
    },
    RECIPE_BOOK: {
        enter: async () => {
            console.log('Entering RECIPE_BOOK state');
            const cookbook = await getCookbook();
            let html = '<h2>Recipe Book</h2>';
            html += '<button id="back-to-idle">Back</button>';
            
            // Add import/export buttons
            html += `<div style="margin: 10px 0;">
                <button id="export-recipe-book">Export Recipes</button>
                <button id="import-recipe-book">Import Recipe Book</button>
                <button id="export-inventory">Export Inventory</button>
                <button id="import-inventory">Import Inventory</button>
            </div>`;
            
            // Add search/filter
            html += `<div style="margin: 10px 0;">
                <input type="text" id="search-recipe-book" placeholder="Search recipes..." style="width: 70%; margin-right: 10px;">
                <select id="sort-recipe-book">
                    <option value="date">Date</option>
                    <option value="name">Name</option>
                    <option value="rating">Rating</option>
                </select>
            </div>`;

            if (cookbook.length === 0) {
                html += '<p>No saved recipes yet.</p>';
            } else {
                // Sort by date descending (newest first)
                const sortedCookbook = [...cookbook].sort((a, b) => new Date(b.date || 0) - new Date(a.date || 0));
                
                html += '<div id="recipe-list">';
                html += '<ul>';
                sortedCookbook.forEach((recipe, index) => {
                    const recipeName = recipe.name || 'My Dicey Drink';
                    const rating = recipe.rating || 0;
                    const notes = recipe.notes || '';
                    const date = recipe.date ? new Date(recipe.date).toLocaleDateString() : 'Unknown date';
                    
                    html += `<li style="text-align: left; padding: 10px; margin: 5px 0; background: #333; border-radius: 4px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>${recipeName}</strong>
                                <div>Rating: ${'★'.repeat(rating)}${'☆'.repeat(5-rating)}</div>
                                <div style="font-size: 0.9em; color: #aaa;">${date}</div>
                                ${notes ? `<div style="font-style: italic; margin-top: 5px;">"${notes}"</div>` : ''}
                            </div>
                            <div>
                                <button class="remix-recipe" data-index="${index}" style="display: block; margin: 2px 0;">Remix</button>
                                <button class="view-recipe" data-index="${index}" style="display: block; margin: 2px 0;">View</button>
                            </div>
                        </div>
                    </li>`;
                });
                html += '</ul>';
                html += '</div>';
            }

            appContainer.innerHTML = html;

            document.getElementById('back-to-idle').addEventListener('click', () => transitionTo('IDLE'));
            
            // Add export functionality
            document.getElementById('export-recipe-book').addEventListener('click', () => exportCookbook(cookbook));
            
            // Add import functionality
            document.getElementById('import-recipe-book').addEventListener('click', () => importCookbook());
            
            // Add export inventory functionality
            document.getElementById('export-inventory').addEventListener('click', () => exportInventory());
            
            // Add import inventory functionality
            document.getElementById('import-inventory').addEventListener('click', () => importInventory());
            
            // Add search functionality
            document.getElementById('search-recipe-book').addEventListener('input', (e) => {
                filterCookbook(cookbook, e.target.value, document.getElementById('sort-recipe-book').value);
            });
            
            // Add sort functionality
            document.getElementById('sort-recipe-book').addEventListener('change', (e) => {
                filterCookbook(cookbook, document.getElementById('search-recipe-book').value, e.target.value);
            });
            
            // Add remix functionality
            document.querySelectorAll('.remix-recipe').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    remixRecipe(cookbook[index]);
                });
            });
            
            // Add view functionality
            document.querySelectorAll('.view-recipe').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    viewRecipe(cookbook[index]);
                });
            });
        },
        exit: () => {
            console.log('Exiting RECIPE_BOOK state');
        }
    }
};

function displayDealersChoice(type, candidates) {
    // Play joker sound when showing dealer's choice
    playJokerSound();
    
    let html = `<h2>Dealer's Choice!</h2><p>Select your ${type}:</p>`;
    candidates.forEach(item => {
        html += `<button class="choice-btn" data-id="${item.id}" data-type="${type}">${item.name}</button>`;
    });
    appContainer.innerHTML = html;

    document.querySelectorAll('.choice-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const itemId = e.target.dataset.id;
            const type = e.target.dataset.type;
            const item = candidates.find(c => c.id === itemId);
            
            if (type === 'spirit_family') {
                state.recipe.spiritFamilies.push(item);
                addProgressStep(`Spirit Family: ${item.name}`);
            } else if (type === 'secondary') {
                state.recipe.secondaries.push(item);
                state.selectedItems.push(item);
                addProgressStep(`Secondary: ${item.name}`);
            } else {
                state.recipe[type + 's'].push(item);
                state.selectedItems.push(item);
                addProgressStep(`${type.charAt(0).toUpperCase() + type.slice(1)}: ${item.name}`);
            }
            transitionTo('PICKS');
        });
    });
}

// --- Method roll helpers ---

async function displayMethodJoker(methodsCore) {
    try { 
        playJokerSound(); 
    } catch (_err) { 
        // sound playback failed silently 
    }    
    const rollWrap = document.createElement('div');
    rollWrap.className = 'roll-wrap';
    appContainer.innerHTML = '<h2>Dealer\'s Choice!</h2>';
    appContainer.appendChild(rollWrap);
    try {
        await roll3D({ parent: rollWrap, N: methodsCore.length, k: 'joker', durationMs: 1200 });
    } catch (_err) { // 3D roll animation failed silently }
    // Show manual method chooser
    const html = `
        <h3 style="margin-top:8px;">Pick a Method</h3>
        ${methodsCore.map(m => `<button class="method-btn" data-method="${m}">${m}</button>`).join('')}
    `;
    const chooser = document.getElementById('method-chooser');
    if (chooser) {
        chooser.style.display = 'block';
        chooser.innerHTML = html;
    } else {
        const div = document.createElement('div');
        div.id = 'method-chooser';
        div.innerHTML = html;
        appContainer.appendChild(div);
    }
    document.querySelectorAll('.method-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const method = e.target.dataset.method;
            appContainer.innerHTML = '';
            transitionTo('BUILD_RECIPE', { method });
        });
    });
}

async function displayMethodRollResult(picked) {
    try { playRollSound(); } catch (_err) {}
    const rollWrap = document.createElement('div');
    rollWrap.className = 'roll-wrap';
    appContainer.innerHTML = '<h2>Rolling...</h2>';
    appContainer.appendChild(rollWrap);
    try {
        await roll3D({ parent: rollWrap, N: 4, k: 1, durationMs: 1000 });
    } catch (_err) {
        // 3D roll animation failed silently 
    }    appContainer.innerHTML = `
        <h2>You rolled: ${picked}</h2>
        <button id="confirm-method">Confirm</button>
    `;
    }
    document.getElementById('confirm-method').addEventListener('click', () => {
        appContainer.innerHTML = '';
        transitionTo('BUILD_RECIPE', { method: picked });
    });
}

async function displayAnimatedPick(item, type, candidates) {
    // Play roll sound
    if (item.name === 'ðŸƒ') {
        playJokerSound();
    } else {
        playRollSound();
    }
    
    // Create a wrapper for the animation
    const rollWrap = document.createElement('div');
    rollWrap.className = 'roll-wrap';
    
    // The original code used 'k' before its 'let' declaration, causing a parse-time error.
    let k;
    // Use the same joker emoji ('ðŸƒ ') as used elsewhere in the app for consistency.
    const isJoker = (item && item.name === 'ðŸƒ '); 
    
    if (isJoker) {
        k = 'joker'; // Use sentinel value for joker animation
    } else {
        k = candidates.findIndex(candidate => candidate.id === item.id) + 1;
        if (k === 0) k = 1; // Fallback to 1 if not found
    }
    
    const N = candidates.length || 1;
    
    // Show the animation
    if (isJoker) {
        // For joker, directly show the joker symbol
        appContainer.innerHTML = '<h2>Dealer\'s Choice!</h2>';
        appContainer.appendChild(rollWrap);
        
        try {
            // Perform the 3D roll animation with joker sentinel
            await roll3D({ 
                parent: rollWrap, 
                N: N, 
                k: k, // This will be 'joker'
                durationMs: 1200
            });
            
            // Show the manual selection UI after animation
            displayDealersChoice(type, candidates);
        } catch (error) {
            console.error('Animation error, falling back to simple display:', error);
            // Fallback to simple display
            displayDealersChoice(type, candidates);
        }
    } else {
        appContainer.innerHTML = '<h2>Rolling...</h2>';
        appContainer.appendChild(rollWrap);
        
        try {
            // Perform the 3D roll animation
            await roll3D({ 
                parent: rollWrap, 
                N: N, 
                k: k,
                durationMs: 1200
            });
            
            // After animation, show the result
            setTimeout(() => {
                appContainer.innerHTML = `
                    <h2>You rolled: ${item.name}</h2>
                    ${state.rerollTokens > 0 ? `<button id="reroll-btn">Reroll (${state.rerollTokens} left)</button>` : ''}
                    <button id="confirm-btn">Confirm</button>
                `;
                
                if (state.rerollTokens > 0) {
                    document.getElementById('reroll-btn').addEventListener('click', () => {
                        state.rerollTokens--;
                        if (type === 'spirit_family') {
                            transitionTo('PICK_SPIRIT_FAMILY');
                        } else if (type === 'secondary') {
                            transitionTo('PICK_SECONDARY');
                        } else {
                            transitionTo(`PICK_${type.toUpperCase()}`);
                        }
                    });
                }
                
                document.getElementById('confirm-btn').addEventListener('click', () => {
                    playConfirmSound();
                    if (type === 'spirit_family') {
                        state.recipe.spiritFamilies.push(item);
                        addProgressStep(`Spirit Family: ${item.name}`);
                    } else if (type === 'secondary') {
                        state.recipe.secondaries.push(item);
                        state.selectedItems.push(item);
                        addProgressStep(`Secondary: ${item.name}`);
                    } else {
                        state.recipe[type + 's'].push(item);
                        state.selectedItems.push(item);
                        addProgressStep(`${type.charAt(0).toUpperCase() + type.slice(1)}: ${item.name}`);
                    }
                    transitionTo('PICKS');
                });
            }, 300);
        } catch (error) {
            console.error('Animation error, falling back to simple display:', error);
            // Fallback to simple display
            displayPick(item, type);
        }
    }
}

function displayPick(item, type) {
    let html = `<h2>You rolled: ${item.name}</h2>`;
    if (state.rerollTokens > 0) {
        html += `<button id="reroll-btn">Reroll (${state.rerollTokens} left)</button>`;
    }
    html += '<button id="confirm-btn">Confirm</button>';
    appContainer.innerHTML = html;

    if (state.rerollTokens > 0) {
        document.getElementById('reroll-btn').addEventListener('click', () => {
            state.rerollTokens--;
            if (type === 'spirit_family') {
                transitionTo('PICK_SPIRIT_FAMILY');
            } else if (type === 'secondary') {
                transitionTo('PICK_SECONDARY');
            } else {
                transitionTo(`PICK_${type.toUpperCase()}`);
            }
        });
    }

    document.getElementById('confirm-btn').addEventListener('click', () => {
        playConfirmSound();
        if (type === 'spirit_family') {
            state.recipe.spiritFamilies.push(item);
            addProgressStep(`Spirit Family: ${item.name}`);
        } else if (type === 'secondary') {
            state.recipe.secondaries.push(item);
            state.selectedItems.push(item);
            addProgressStep(`Secondary: ${item.name}`);
        } else {
            state.recipe[type + 's'].push(item);
            state.selectedItems.push(item);
            addProgressStep(`${type.charAt(0).toUpperCase() + type.slice(1)}: ${item.name}`);
        }
        transitionTo('PICKS');
    });
}

function transitionTo(newState, context = {}) {
    if (states[state.currentState] && states[state.currentState].exit) {
        states[state.currentState].exit();
    }
    state.currentState = newState;
    if (states[state.currentState] && states[state.currentState].enter) {
        states[state.currentState].enter(context);
    }
    updateProgressDrawer();
}

// Expose a simple Home action for the topbar button
window.goHome = () => transitionTo('IDLE');

// Also bind the header Home icon without relying on inline handlers
const __homeBtn = document.getElementById('home-btn');
if (__homeBtn) {
    __homeBtn.addEventListener('click', () => transitionTo('IDLE'));
}

// --- Dev Validations Panel (Phase 3 validation helpers) ---
function devIsWebGLSupported() {
    try {
        const canvas = document.createElement('canvas');
        return !!(
            window.WebGLRenderingContext &&
            (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'))
        );
    } catch (e) {
        return false;
    }
}

function renderDevPanel() {
    const containerId = 'dev-validations-panel';
    let panel = document.getElementById(containerId);
    if (!panel) {
        panel = document.createElement('div');
        panel.id = containerId;
        panel.style.margin = '16px auto';
        panel.style.maxWidth = '420px';
        panel.style.background = '#222';
        panel.style.border = '1px solid #00ffff';
        panel.style.borderRadius = '6px';
        panel.style.padding = '12px';
        const info = document.createElement('div');
        info.id = 'dev-info';
        const buttons = document.createElement('div');
        buttons.style.marginTop = '8px';
        const runBtn = document.createElement('button');
        runBtn.textContent = 'Run Anim Perf';
        runBtn.style.marginRight = '8px';
        const forceFallbackBtn = document.createElement('button');
        forceFallbackBtn.textContent = 'Force Fallback Roll';
        const output = document.createElement('div');
        output.id = 'dev-output';
        output.style.marginTop = '10px';
        output.style.textAlign = 'left';
        output.style.fontFamily = 'monospace';
        output.style.fontSize = '12px';
        const mount = document.createElement('div');
        mount.id = 'dev-mount';
        mount.className = 'roll-wrap';
        mount.style.marginTop = '12px';
        buttons.appendChild(runBtn);
        buttons.appendChild(forceFallbackBtn);
        panel.appendChild(info);
        panel.appendChild(buttons);
        panel.appendChild(output);
        panel.appendChild(mount);
        // Attach under app container
        appContainer.insertAdjacentElement('afterend', panel);

        // Populate environment info
        const reduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        info.innerHTML = `
            <div><strong>Dev Validations</strong></div>
            <div>WebGL: ${devIsWebGLSupported() ? 'supported' : 'not supported'}</div>
            <div>Reduced motion: ${reduced ? 'true' : 'false'}</div>
        `;

        // Perf runner using 3D or fallback depending on support
        runBtn.addEventListener('click', async () => {
            const parent = document.getElementById('dev-mount');
            if (!parent) return;
            parent.innerHTML = '';
            const N = 12; const k = 7;
            const start = performance.now();
            try {
                await roll3D({ parent, N, k, durationMs: 1200 });
            } catch (e) {
                await rollFallback({ parent, N, k, durationMs: 1200 });
            }
            const end = performance.now();
            const duration = Math.round(end - start);
            const ok = duration <= 1200 ? 'OK' : 'SLOW';
            document.getElementById('dev-output').textContent = `Anim duration: ${duration} ms (${ok})`;
        });

        // Always use fallback path to validate number flip
        forceFallbackBtn.addEventListener('click', async () => {
            const parent = document.getElementById('dev-mount');
            if (!parent) return;
            parent.innerHTML = '';
            const N = 10; const k = 'joker';
            const start = performance.now();
            await rollFallback({ parent, N, k, durationMs: 900 });
            const end = performance.now();
            const duration = Math.round(end - start);
            document.getElementById('dev-output').textContent = `Fallback duration: ${duration} ms`;
        });
    } else {
        // Toggle visibility
        panel.style.display = (panel.style.display === 'none') ? '' : 'none';
    }
}

// Show modal for share code import with options to save or view only
function showShareCodeImportModal(recipe) {
    const recipeName = recipe.name || 'Shared Recipe';
    
    let html = `
        <div id="share-code-modal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center; z-index: 1000;">
            <div style="background: #222; padding: 20px; border-radius: 8px; max-width: 500px; width: 80%;">
                <h2>Shared Recipe Import</h2>
                <p>You've received a shared recipe: <strong>${recipeName}</strong></p>
                <p>What would you like to do?</p>
                <div style="margin-top: 20px;">
                    <button id="save-to-recipe-book" style="margin-right: 10px;">Save to Recipe Book</button>
                    <button id="view-only" style="margin-right: 10px;">View Only</button>
                    <button id="cancel-import">Cancel</button>
                </div>
            </div>
        </div>
    `;
    
    appContainer.innerHTML = html;
    
    document.getElementById('save-to-recipe-book').addEventListener('click', () => {
        // Add to recipe book and go to recipe view
        recipe.date = new Date().toISOString();
        addRecipeToCookbook(recipe);
        state.recipe = recipe;
        document.getElementById('share-code-modal').remove();
        transitionTo('RECIPE');
    });
    
    document.getElementById('view-only').addEventListener('click', () => {
        // Just view the recipe without saving
        state.recipe = recipe;
        document.getElementById('share-code-modal').remove();
        transitionTo('RECIPE');
    });
    
    document.getElementById('cancel-import').addEventListener('click', () => {
        // Cancel and go to IDLE
        document.getElementById('share-code-modal').remove();
        transitionTo('IDLE');
    });
}

function findItem(itemId) {
    const category = itemId.split('.')[0] + 's';
    return data.inventory[category].find(item => item.id === itemId);
}

function showNoSolutionMessage(message) {
    appContainer.innerHTML = `
        <h2>No Valid Options</h2>
        <p>${message}</p>
        <p>This combination of ingredients violates compatibility rules.</p>
        <button id="back-btn">Go Back</button>
    `;
    
    document.getElementById('back-btn').addEventListener('click', () => {
        // Remove the last selection and go back to the previous pick state
        let removedItem = null;
            if (state.recipe.secondaries && state.recipe.secondaries.length > 0) {
                removedItem = state.recipe.secondaries.pop();
                const index = state.selectedItems.findIndex(i => i.id === removedItem.id);
                if (index > -1) state.selectedItems.splice(index, 1);
            } else if (state.recipe.additives.length > 0) {
                removedItem = state.recipe.additives.pop();
                const index = state.selectedItems.findIndex(i => i.id === removedItem.id);
                if (index > -1) state.selectedItems.splice(index, 1);
            } else if (state.recipe.mixers.length > 0) {
                removedItem = state.recipe.mixers.pop();
                const index = state.selectedItems.findIndex(i => i.id === removedItem.id);
                if (index > -1) state.selectedItems.splice(index, 1);
            } else if (state.recipe.spirits.length > 0) {
                removedItem = state.recipe.spirits.pop();
                const index = state.selectedItems.findIndex(i => i.id === removedItem.id);
                if (index > -1) state.selectedItems.splice(index, 1);
            } else if (state.recipe.spiritFamilies && state.recipe.spiritFamilies.length > 0) {
                removedItem = state.recipe.spiritFamilies.pop();
            }
        
        if (removedItem) {
            addProgressStep(`Reverted: Removed ${removedItem.name}`);
        }
        
        transitionTo('PICKS');
    });
}

// Export recipe book as JSON file
function exportCookbook(cookbook) {
    // Add date to export
    const exportData = {
        version: 1,
        exported: new Date().toISOString(),
        recipes: cookbook
    };
    
    const dataStr = JSON.stringify(exportData, null, 2);
    const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
    
    const exportFileDefaultName = `dicey-drinks-recipe-book-${new Date().toISOString().slice(0,10)}.json`;
    
    const linkElement = document.createElement('a');
    linkElement.setAttribute('href', dataUri);
    linkElement.setAttribute('download', exportFileDefaultName);
    linkElement.click();
}

// Export inventory as JSON file
function exportInventory() {
    // Get current inventory data
    getData().then(data => {
        // Prepare export data
        const exportData = {
            version: 1,
            exported: new Date().toISOString(),
            inventory: data.inventory,
            subpools: data.subpools,
            secondary: data.secondary,
            rules: data.rules
        };
        
        const dataStr = JSON.stringify(exportData, null, 2);
        const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
        
        const exportFileDefaultName = `dicey-drinks-inventory-${new Date().toISOString().slice(0,10)}.json`;
        
        const linkElement = document.createElement('a');
        linkElement.setAttribute('href', dataUri);
        linkElement.setAttribute('download', exportFileDefaultName);
        linkElement.click();
    }).catch(error => {
        console.error('Error exporting inventory:', error);
        alert('Error exporting inventory: ' + error.message);
    });
}

// Import recipe book from JSON file
function importCookbook() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    
    input.onchange = e => {
        const file = e.target.files[0];
        const reader = new FileReader();
        
        reader.onload = function(event) {
            try {
                const data = JSON.parse(event.target.result);
                
                if (data.version !== 1) {
                    alert('Unsupported file version');
                    return;
                }
                
                if (!data.recipes || !Array.isArray(data.recipes)) {
                    alert('Invalid recipe book file format');
                    return;
                }
                
                // Import recipes
                importRecipes(data.recipes);
            } catch (error) {
                alert('Error parsing recipe book file: ' + error.message);
            }
        };
        
        reader.readAsText(file);
    };
    
    input.click();
}

// Import inventory from JSON file
function importInventory() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    
    input.onchange = e => {
        const file = e.target.files[0];
        const reader = new FileReader();
        
        reader.onload = function(event) {
            try {
                const data = JSON.parse(event.target.result);
                
                if (data.version !== 1) {
                    alert('Unsupported file version');
                    return;
                }
                
                // Import inventory data
                importInventoryData(data);
            } catch (error) {
                alert('Error parsing inventory file: ' + error.message);
            }
        };
        
        reader.readAsText(file);
    };
    
    input.click();
}

// Import recipes into the database
async function importRecipes(recipes) {
    try {
        for (const recipe of recipes) {
            // Ensure recipe has required fields
            if (!recipe.date) {
                recipe.date = new Date().toISOString();
            }
            await addRecipeToCookbook(recipe);
        }
        alert(`Successfully imported ${recipes.length} recipes!`);
        transitionTo('RECIPE_BOOK'); // Refresh the view
    } catch (error) {
        console.error('Error importing recipes:', error);
        alert('Error importing recipes: ' + error.message);
    }
}

// Import inventory data into the database
async function importInventoryData(data) {
    try {
        // Use the new replaceInventoryData function
        await replaceInventoryData(data);
        
        // Refresh the app data
        data = await getData();
        
        alert('Successfully imported inventory data!');
        transitionTo('INVENTORY'); // Refresh the view
    } catch (error) {
        console.error('Error importing inventory:', error);
        alert('Error importing inventory: ' + error.message);
    }
}

// Filter and sort recipe book
function filterCookbook(cookbook, searchTerm, sortBy) {
    let filtered = [...cookbook];
    
    // Apply search filter
    if (searchTerm) {
        filtered = filtered.filter(recipe => {
            const name = (recipe.name || 'My Dicey Drink').toLowerCase();
            const notes = (recipe.notes || '').toLowerCase();
            return name.includes(searchTerm.toLowerCase()) || notes.includes(searchTerm.toLowerCase());
        });
    }
    
    // Apply sorting
    switch (sortBy) {
    case 'name':
        filtered.sort((a, b) => (a.name || 'My Dicey Drink').localeCompare(b.name || 'My Dicey Drink'));
        break;
    case 'rating':
        filtered.sort((a, b) => (b.rating || 0) - (a.rating || 0));
        break;
    case 'date':
    default:
        filtered.sort((a, b) => new Date(b.date || 0) - new Date(a.date || 0));
        break;
    }
    
    // Update the recipe list
    const listContainer = document.getElementById('recipe-list');
    if (listContainer) {
        let html = '<ul>';
        filtered.forEach((recipe, index) => {
            const recipeName = recipe.name || 'My Dicey Drink';
            const rating = recipe.rating || 0;
            const notes = recipe.notes || '';
            const date = recipe.date ? new Date(recipe.date).toLocaleDateString() : 'Unknown date';
            
            html += `<li style="text-align: left; padding: 10px; margin: 5px 0; background: #333; border-radius: 4px;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <strong>${recipeName}</strong>
                        <div>Rating: ${'★'.repeat(rating)}${'☆'.repeat(5-rating)}</div>
                        <div style="font-size: 0.9em; color: #aaa;">${date}</div>
                        ${notes ? `<div style="font-style: italic; margin-top: 5px;">"${notes}"</div>` : ''}
                    </div>
                    <div>
                        <button class="remix-recipe" data-index="${index}" style="display: block; margin: 2px 0;">Remix</button>
                        <button class="view-recipe" data-index="${index}" style="display: block; margin: 2px 0;">View</button>
                    </div>
                </div>
            </li>`;
        });
        html += '</ul>';
        
        listContainer.innerHTML = html;
        
        // Reattach event listeners
        document.querySelectorAll('.remix-recipe').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const index = parseInt(e.target.dataset.index);
                remixRecipe(filtered[index]);
            });
        });
        
        document.querySelectorAll('.view-recipe').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const index = parseInt(e.target.dataset.index);
                viewRecipe(filtered[index]);
            });
        });
    }
}

// Remix a recipe with small perturbations
function remixRecipe(recipe) {
    // Create a new recipe based on the original with small perturbations
    const remixedRecipe = {
        ...recipe,
        // Clear any existing ID/date so it gets a new one when saved
        id: undefined,
        date: undefined,
        // Add a note that this is a remix
        name: `${recipe.name || 'My Dicey Drink'} (Remix)`,
        // For a basic implementation, we'll just start a new build with the same parameters
        // A more advanced implementation would use the seed/roll trace with perturbations
    };
    
    // Set the state to start a new build with the same parameters
    state.recipe = {
        type: recipe.type,
        method: recipe.method,
        style: recipe.style,
        numSpirits: recipe.spirits ? recipe.spirits.length : 1,
        numMixers: recipe.mixers ? recipe.mixers.length : 0,
        numAdditives: recipe.additives ? recipe.additives.length : 0,
        spirits: [],
        spiritFamilies: [],
        mixers: [],
        additives: [],
        secondaries: []
    };
    
    // Transition to the appropriate state to start building
    if (state.recipe.type === 'drink') {
        transitionTo('ROCKS_NEAT');
    } else {
        transitionTo('HOW_MANY');
    }
}

// View a recipe in detail
function viewRecipe(recipe) {
    // Show the recipe details
    const recipeName = recipe.name || 'My Dicey Drink';
    let html = `<h2>${recipeName}</h2>`;
    html += `<p><strong>Method:</strong> ${recipe.method || 'Unknown'}</p>`;
    
    if (recipe.style) {
        html += `<p><strong>Style:</strong> ${recipe.style}</p>`;
    }
    
    html += `<p><strong>Rating:</strong> ${'★'.repeat(recipe.rating || 0)}${'☆'.repeat(5 - (recipe.rating || 0))}</p>`;
    
    if (recipe.notes) {
        html += `<p><strong>Notes:</strong> ${recipe.notes}</p>`;
    }
    
    if (recipe.date) {
        html += `<p><strong>Date:</strong> ${new Date(recipe.date).toLocaleDateString()}</p>`;
    }
    
    html += '<h3>Ingredients:</h3><ul>';
    // Show actual ingredients
    if (recipe.spirits) {
        recipe.spirits.forEach(spirit => {
            html += `<li>${spirit.name}</li>`;
        });
    }
    if (recipe.mixers) {
        recipe.mixers.forEach(mixer => {
            html += `<li>${mixer.name}</li>`;
        });
    }
    if (recipe.additives) {
        recipe.additives.forEach(additive => {
            html += `<li>${additive.name}</li>`;
        });
    }
    html += '</ul>';
    
    html += '<div style="margin-top: 20px;">';
    html += '<button id="back-to-recipe-book">Back to Recipe Book</button>';
    html += '<button id="rebuild-recipe" style="margin-left: 10px;">Rebuild Recipe</button>';
    html += '</div>';
    
    appContainer.innerHTML = html;
    
    document.getElementById('back-to-recipe-book').addEventListener('click', () => transitionTo('RECIPE_BOOK'));
    document.getElementById('rebuild-recipe').addEventListener('click', () => rebuildRecipe(recipe));
}

// Rebuild a recipe from its saved state
function rebuildRecipe(recipe) {
    // Set the state to the saved recipe
    state.recipe = { ...recipe };
    
    // Transition to the RECIPE state to view/edit/export
    transitionTo('RECIPE');
}

// Progress drawer functions
function initProgressDrawer() {
    progressDrawer.steps = [];
    progressDrawer.currentStep = 0;
    renderProgressDrawer();
}

function addProgressStep(stepName) {
    progressDrawer.steps.push(stepName);
    progressDrawer.currentStep = progressDrawer.steps.length - 1;
    updateProgressDrawer();
}

function updateProgressDrawer() {
    renderProgressDrawer();
}

function toggleProgressDrawer() {
    progressDrawer.isOpen = !progressDrawer.isOpen;
    renderProgressDrawer();
}

function renderProgressDrawer() {
    const container = document.getElementById('progress-drawer-container');
    if (!container) return;

    if (!state.sessionActive) {
        container.style.display = 'none';
        return;
    }
    container.style.display = 'block';

    // Create the drawer element if it doesn't exist
    if (!progressDrawerElement) {
        progressDrawerElement = document.createElement('div');
        progressDrawerElement.className = 'progress-drawer';
        container.appendChild(progressDrawerElement);
    }

    // Create header
    let header = progressDrawerElement.querySelector('.progress-drawer-header');
    if (!header) {
        header = document.createElement('div');
        header.className = 'progress-drawer-header';
        progressDrawerElement.appendChild(header);
        
        const title = document.createElement('span');
        title.textContent = 'Progress';
        header.appendChild(title);
        
        const toggleButton = document.createElement('button');
        toggleButton.className = 'progress-drawer-toggle';
        toggleButton.textContent = progressDrawer.isOpen ? '▼' : '▶';
        toggleButton.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleProgressDrawer();
        });
        header.addEventListener('click', toggleProgressDrawer);
        header.appendChild(toggleButton);
    } else {
        // Update toggle button text
        const toggleButton = header.querySelector('.progress-drawer-toggle');
        if (toggleButton) {
            toggleButton.textContent = progressDrawer.isOpen ? '▼' : '▶';
        }
    }

    // Create or update content
    let content = progressDrawerElement.querySelector('.progress-drawer-content');
    if (!content) {
        content = document.createElement('div');
        content.className = 'progress-drawer-content';
        progressDrawerElement.appendChild(content);
    }

    // Update content based on steps
    if (progressDrawer.steps.length > 0) {
        let html = '<ul>';
        progressDrawer.steps.forEach((step, index) => {
            const isCurrent = index === progressDrawer.currentStep;
            html += `<li class="progress-step ${isCurrent ? 'current' : ''}">${step}</li>`;
        });
        html += '</ul>';
        content.innerHTML = html;
    } else {
        content.innerHTML = '<p>No steps yet</p>';
    }

    // Toggle open/closed class
    if (progressDrawer.isOpen) {
        progressDrawerElement.classList.add('open');
    } else {
        progressDrawerElement.classList.remove('open');
    }
}

function highlightAndSlideUp(element, callback) {
    element.classList.add('slide-up');
    setTimeout(callback, 500); // Match animation duration
}

async function rollForUniqueItems(category, numToRoll, availableItems) {
    const rolledItems = [];
    let remainingItems = [...availableItems];

    for (let i = 0; i < numToRoll; i++) {
        if (cryptoRoll(20) === 20) { // Joker
            rolledItems.push({ name: 'ðŸƒ', isJoker: true });
            continue;
        }

        if (remainingItems.length === 0) break;

        const weights = remainingItems.map(item => getSoftWeight(item, state.selectedItems.concat(rolledItems), data.rules.soft_rules));
        const selectedItem = weightedCryptoChoice(remainingItems, weights);
        
        rolledItems.push(selectedItem);
        remainingItems = remainingItems.filter(item => item.id !== selectedItem.id);
    }

    return rolledItems;
}

// Initial transition
transitionTo('LOADING');
